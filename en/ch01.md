# 1 Introduction

JavaScript applications such as web e-mail, maps, document editing, and collaboration tools are becoming an increasingly important part of the everyday computing. We designed TypeScript to meet the needs of the JavaScript programming teams that build and maintain large JavaScript programs. TypeScript helps programming teams to define interfaces between software components and to gain insight into the behavior of existing JavaScript libraries. TypeScript also enables teams to reduce naming conflicts by organizing their code into dynamically-loadable modules. TypeScript's optional type system enables JavaScript programmers to use highly-productive development tools and practices: static checking, symbol-based navigation, statement completion, and code re-factoring.

メール、地図、文書編集、協同作業ツールなどのJavaScriptアプリケーションは、日々のコンピューティングにおける重要な位置を占めてきています。我々は、大規模なJavaScriptプログラムを構築・メンテナンスするプログラミングチームからのニーズに合うように、TypeScriptを設計しています。TypeScriptは、ソフトウエアコンポーネント間のインターフェースを定義し、既存のJavaScriptライブラリの挙動に関する理解を深めることで、プログラミングチームを支援します。同時に、コードを動的にロード可能なモジュールにすることで、名前が衝突する可能性を低減させます。TypeScriptのオプションの型システムは、JavaScriptプログラマーに静的チェック、シンボルベースのナビゲーション、構文補完、リファクタリングなどの高生産性ツールを用いてプラクティスを実践することができます。

TypeScript is a syntactic sugar for JavaScript. TypeScript syntax is a superset of Ecmascript 5 (ES5) syntax. Every JavaScript program is also a TypeScript program. The TypeScript compiler performs only file-local transformations on TypeScript programs and does not re-order variables declared in TypeScript. This leads to JavaScript output that closely matches the TypeScript input. TypeScript does not transform variable names, making tractable the direct debugging of emitted JavaScript. TypeScript optionally provides source maps, enabling source-level debugging. TypeScript tools typically emit JavaScript upon file save, preserving the test, edit, refresh cycle commonly used in JavaScript development.

TypeScriptはJavaScriptへの糖衣構文（syntactic sugar）です。TypeScriptの構文は、ECMAScript 5（ES5）構文のスーパーセットです。全てのJavaScriptプログラムはTypeScriptプログラムでもあります。TypeScriptコンパイラーはTypeScriptのファイル内にあるものだけを変換し、変数宣言の順序変更を行いません。このことはTypeScriptの入力によく一致したJavaScriptの出力をもたらします。TypeScriptは変数名を変更しないので、発行されたJavaScriptを直接デバッグすることを扱いやすくします。TypeScriptはオプションでソースマップを提供し、ソースレベルのデバッグが可能です。TypeScriptのツールはファイルセーブと同時にJavaScriptを発行することで、JavaScriptのテスト、編集、開発で一般的なリフレッシュサイクルを保ちます。

TypeScript syntax includes several proposed features of Ecmascript 6 (ES6), including classes and modules. Classes enable programmers to express common object-oriented patterns in a standard way, making features like inheritance more readable and interoperable. Modules enable programmers to organize their code into components while avoiding naming conflicts. The TypeScript compiler provides module code generation options that support either static or dynamic loading of module contents.

TypeScriptの構文はECMAScript6（ES6）で提案されているクラスやモジュールなど機能の一部を含んでいます。クラスは標準的な方法でオブジェクト指向パターンをプログラマーが記述することを可能にし、継承などの機能は可読性と相互運用性を高めます。モジュールはプログラマーに名前衝突を避けながらコードをコンポーネントとしてまとめることを可能にします。TypeScriptコンパイラーは、モジュールの内容を静的もしくは動的ローディングをサポートするコード生成オプションを提供します。

TypeScript also provides to JavaScript programmers a system of optional type annotations. These type annotations are like the JSDoc comments found in the Closure system, but in TypeScript they are integrated directly into the language syntax. This integration makes the code more readable and reduces the maintenance cost of synchronizing type annotations with their corresponding variables.

TypeScriptもオプションの型注釈のシステムをJavaScriptプログラマーに提供します。これらの型注釈はClosureに見られるJSDocコメントに似ていますが、TypeScriptでは言語構文に直接統合されています。この統合はコードの可読性が向上し、対応する変数と型注釈を同期させるメンテナンスコストを低減させます。

The TypeScript type system enables programmers to express limits on the capabilities of JavaScript objects, and to use tools that enforce these limits. To minimize the number of annotations needed for tools to become useful, the TypeScript type system makes extensive use of type inference. For example, from the following statement, TypeScript will infer that the variable `i` has the type number.

TypeScriptの型システムは、JavaScriptオブジェクトの機能制限を表現することを可能にし、ツールを利用することでこれらの制限を強制することができます。ツールが必要とする注釈の量を最小にするために、TypeScriptの型システムは型推論を広範囲に利用します。例として、以下のような宣言では、TypeScriptは変数`i`がnumber型であると推論します。

```javascript
var i = 0;
```

TypeScript will infer from the following function definition that the function f has return type string.

TypeScriptは以下にある関数fの関数定義から、戻り値の型がstringであると推論します。

```javascript
function f() {
    return "hello";
}
```

To benefit from this inference, a programmer can use the TypeScript language service. For example, a code editor can incorporate the TypeScript language service and use the service to find the members of a string object as in the following screen shot.

この推論から利益を得るために、プログラマーはTypeScriptランゲージサービスを利用することができます。例えば、コードエディターはTypeScriptランゲージサービスを取り込むことができ、以下のスクリーンショットのようなstringオブジェクトのメンバーを見つけるためにサービスを利用することができます。

In this example, the programmer benefits from type inference without providing type annotations. Some beneficial tools, however, do require the programmer to provide type annotations. In TypeScript, we can express a parameter requirement as in the following code fragment.

この例では、プログラマーは型注釈を提供することなく、型推論から恩恵をを得ることができます。しかしいくつかの有益なツールは、型注釈を提供するようプログラマーに求めます。TypeScriptでは、以下のコードのように要求するパラメータを表現することができます。

```typescript
function f(s: string) {
    return s;
}

f({});      // Error
f("hello"); // Ok
```

This optional type annotation on the parameter `s` lets the TypeScript type checker know that the programmer expects parameter `s` to be of type `string`. Within the body of function `f`, tools can assume `s` is of type `string` and provide operator type checking and member completion consistent with this assumption. Tools can also signal an error on the first call to `f`, because `f` expects a string, not an object, as its parameter.

引数`s`に対するオプションの型注釈は、プログラマーが引数`s`が`string`型であることを期待しているとTypeScript型チェッカーに知らせます。関数fの内容の範囲で、ツールは`s`が`string`であると仮定し、この仮定に基づいた演算子型チェックとメンバー補完を提供します。関数`f`は引数に`object`ではなく`string`を期待しているため、ツールは1回目の関数fを呼び出している部分でエラーを発生させることも可能です。

For the function `f`, the TypeScript compiler will emit the following JavaScript code:

関数`f`について、TypeScriptコンパイラーは以下のようなJavaScriptを発行します。

```javascript
function f(s) {
    return s;
}
```

In the JavaScript output, all type annotations have been erased. In general, TypeScript erases all type
information before emiting JavaScript.

このJavaScriptの出力では、全ての型注釈が削除されています。一般的に、TypeScriptはJavaScriptを発行する前に型に関する情報を全て消去します。

## 1.1 環境宣言(Ambient Declarations)

An ambient declaration introduces a variable into a TypeScript scope, but has zero impact on the emitted JavaScript program. Programmers can use ambient declarations to tell the TypeScript compiler that some other component will supply a variable. For example, by default the TypeScript compiler will print an error for uses of undefined variables. To add some of the common variables defined by browsers, a TypeScript programmer can use ambient declarations. The following example declares the `document` object supplied by browsers. Because the declaration does not specify a type, the type `any` is inferred. The type `any` means that a tool can assume nothing about the shape or behavior of the document object. Some of the examples below will illustrate how programmers can use types to further characterize the expected
behavior of an object.

環境宣言はTypeScriptのスコープに変数を導入しますが、出力されるJavaScriptのプログラムへは何の影響も及ぼしません。プログラマーは環境宣言を、他のコンポーネントが提供する変数をTypeScriptコンパイラーに教えるために利用することができます。例えば、デフォルトではTypeScriptコンパイラーは未定義の変数を使っているエラーをユーザーに表示します。以下の例では、ブラウザが提供する`document`オブジェクトを宣言しています。宣言で型が明示されていないため、`any`型だと推論されます。`any`型は、ツールがdocumentオブジェクトに関する形態や振る舞いについて一切仮定しないことを意味します。以下の例では、プログラマーが期待されるオブジェクトの振る舞いを特徴づけるために型を使用できることを示しています。

```typescript
declare var document;
document.title = "Hello"; // Ok because document has been declared
```

In the case of `document`, the TypeScript compiler automatically supplies a declaration, because TypeScript by default includes a file `lib.d.ts` that provides interface declarations for the built-in JavaScript library as well as the Document Object Model.

この場合の`document`では、TypeScriptがデフォルトでDocument Object ModelとしてJavaScriptライブラリーにビルトインされたインターフェース宣言を提供する`lib.d.ts`をデフォルトでインクルードするため、TypeScriptコンパイラーは自動的に宣言を導入します。

The TypeScript compiler does not include by default an interface for jQuery, so to use jQuery, a programmer could supply a declaration such as:

TypeScriptコンパイラーはjQueryのインターフェースをデフォルトでインクルードしないので、jQueryを利用する場合、プログラマーは以下のようにして宣言を導入します。

```typescript
declare var $;
```

Section 1.3 provides a more extensive example of how a programmer can add type information for jQuery and other libraries.

セクション1.3では、プログラマーがjQueryや他のライブラリーの型情報を追加するための幅広い例を提供します。

## 1.2 関数型(Function Types)

Function expressions are a powerful feature of JavaScript. They enable function definitions to create closures: functions that capture information from the lexical scope surrounding the function's definition. Closures are currently JavaScript's only way of enforcing data encapsulation. By capturing and using environment variables, a closure can retain information that cannot be accessed from outside the closure. JavaScript programmers often use closures to express event handlers and other asynchronous callbacks, in which another software component, such as the DOM, will call back into JavaScript through a handler function.

関数式はJavaScriptの強力な機能です。このことは関数定義でクロージャーの作成を可能にします。(関数定義を囲んでいるレキシカルスコープから情報を取得する機能)クロージャーは現状のJavaScriptでデータをカプセル化する唯一の方法です。環境変数を利用することで、クロージャーは外部からアクセスできない情報を保持することができます。JavaScriptプログラマーは、イベントハンドラーや非同期コールバックの記述にしばしばクロージャーを利用し、DOMなどの他のソフトウエアコンポーネントでは、ハンドラー関数経由でJavaScriptにコールバックします。

TypeScript function types make it possible for programmers to express the expected *signature* of a function. A function signature is a sequence of parameter types plus a return type. The following example uses function types to express the callback signature requirements of an asynchronous voting mechanism.

TypeScriptの関数型は、関数が期待している*シグネチャー*をプログラマーが表現することを可能にします。関数のシグネチャーは、引数の型の順番と、戻り値の型です。以下の例は、非同期投票メカニズムが要求するコールバックシグネチャーの関数型宣言です。

```typescript
function vote(candidate: string, callback: (result: string) => any) {
    // ...
}

vote("BigPig",
    function(result: string) {
        if (result === "BigPig") {
            // ...
        }
    }
);
```

In this example, the second parameter to `vote` has the function type

この例では、2つ目の引数に関数型が指定されています。

```typescript
(result: string) => any
```

which means the second parameter is a function returning type `any` that has a single parameter of type
`string` named `result`.

これは2つ目の引数が、`result`という名前で`string`型の引数を1つ受けて`any`型の戻り値を返す関数であることを示しています。

Section 3.7.2 provides additional information about function types.

セクション3.7.2では関数型に関する追加の情報を提供しています。

## 1.3 オブジェクト型(Object Types)

TypeScript programmers use object types to declare their expectations of object behavior. The following code uses an *object type literal* to specify the return type of the `MakePoint` function.

TypeScriptプログラマーはオブジェクトの振る舞いへの期待を宣言するためにobject型を利用します。以下のコードは`MakePoint`関数の戻り値を明示するために*オブジェクト型リテラル*を利用しています。

```typescript
var MakePoint: () => {
    x: number; y: number;
};
```

Programmers can give names to object types; we call named object types *interfaces*. For example, in the following code, an interface declares one required field (name) and one optional field (favoriteColor).

プログラマーはobject型に名前をつけることができます; 我々は名前が付けられたobject型を*インターフェース*と呼びます。例えば以下のコードでは、インターフェースは1つの必須フィールド(name)とオプションのフィールド(favoriteColor)を宣言しています。

```typescript
interface Friend {
    name: string;
    favoriteColor?: string;
}

function add(friend: Friend) {
    var name = friend.name;
}

add({ name: "Fred" }); // Ok
add({ favoriteColor: "blue" }); // Error, name required
add({ name: "Jill", favoriteColor: "green" }); // Ok
```

TypeScript object types model the diversity of behaviors that a JavaScript object can exhibit. For example, the jQuery library defines an object, `$`, that has methods, such as `get` (which sends an Ajax message), and fields, such as `browser` (which gives browser vendor information). However, jQuery clients can also call `$` as a function. The behavior of this function depends on the type of parameters passed to the function.

TypeScriptのオブジェクトモデルはJavaScriptオブジェクトの振る舞いの多様性を明示することが可能です。例えば、jQueryライブラリのオブジェクトが`$`で定義され、`get`メソッド(Ajaxメッセージを送信する)や、`brouser`フィールド(ブラウザのベンダー情報を保持する)などが定義されています。しかし、jQueryのクライアントは関数のように`$`を呼び出すこともできます。関数としての振る舞いは、関数に渡される引数の型に依存しています。

The following code fragment captures a small subset of jQuery behavior, just enough to use jQuery in a simple way.

以下のコードは、jQueryのふるまいをとらえた小さなサブセットで、単純な方法でjQueryを使うのに十分なものです。

```typescript
interface JQuery {
    text(content: string);
}

interface JQueryStatic {
    get(url: string, callback: (data: string) => any);
    (query: string): JQuery;
}

declare var $: JQueryStatic;

$.get("http://mysite.org/divContent",
    function (data: string) {
        $("div").text(data);
    }
);
```

The `JQueryStatic` interface references another interface: `JQuery`. This interface represents a collection of　one or more DOM elements. The jQuery library can perform many operations on such a collection, but in　this example the jQuery client only needs to know that it can set the text content of each jQuery element　in a collection by passing a string to the `text` method. The `JQueryStatic` interface also contains a　method, `get`, that performs an Ajax get operation on the provided URL and arranges to invoke the povided　callback upon receipt of a response.

`JQueryStatic`インターフェースは別のインターフェースである`JQuery`を参照しています。このインターフェースは1つ以上のDOMエレメントから構成されるコレクションを表しています。jQueryライブラリは、このようなコレクションに対して様々な操作を行うことができますが、このサンプルでは、jQueryクライアントはコレクション内にある各jQuery要素に対して`text`メソッドに文字列を渡すことでコンテンツを設定できることを知っている必要があるだけです。

Finally, the `JQueryStatic` interface contains a bare function signature

結果として、`JQueryStatic`インターフェースはbare function signatureを含んでいます。

```typescript
(query: string): JQuery;
```

The bare signature indicates that instances of the interface are callable. This example illustrates that TypeScript function types are just special cases of TypeScript object types. Specifically, function types are object types that contain one or more call signatures. For this reason we can write any function type as an object type literal. The following example uses both forms to describe the same type.

The bare signatureはこのインターフェースを実装したインスタンスが呼び出せることを示しています。この例は、TypeScriptの関数型は、TypeScriptのobject型の特別な場合と同じであることの証です。具体的には、関数型は1つ以上のcall signaturesを持つobject型と同じです。このため、我々はどんな関数型でもobject型リテラルとして記述することができます。以下の例では、同じ型を記述するために両方の記法を使用しています。

```typescript
var f: { (): string; };
var sameType: () => string = f; // Ok
var nope: () => number = sameType; // Error: type mismatch
```

We mentioned above that the `$` function behaves differently depending on the type of its parameter. So far, our jQuery typing only captures one of these behaviors: return an object of type `JQuery` when passed a string. To specify multiple behaviors, TypeScript supports *overloading* of function signatures in object types. For example, we can add an additional call signature to the `JQueryStatic` interface.

`$`関数は引数の型によって異なる振る舞いを示すことを以前に説明しました。今のところ、我々の作ったjQueryの型は多くの振る舞いのうち、文字列を渡されたら`JQuery`型のオブジェクトを返す振る舞いしかできません。複数の振る舞いを定義するために、TypeScriptではオブジェクトの型に応じた関数シグネチャーの*オーバーロード*をサポートしています。例えば、`JQueryStatic`インターフェースに関数呼び出しシグネチャーを追加することができます。

```typescript
(ready: () => any): any;
```

This signature denotes that a function may be passed as the parameter of the `$` function. When a function is passed to `$`, the jQuery library will invoke that function when a DOM document is ready. Because TypeScript supports overloading, tools can use TypeScript to show all available function signatures with their documentation tips and to give the correct documentation once a function has been called with a particular signature.

このシグネチャーは、関数が`$`関数に与えられたパラメーターとして渡されるかもしれないことを意味しています。`$`に関数が渡された場合、jQueryライブラリはDOMドキュメントの準備ができたらそこ関数を実行します。TypeScriptがオーバーロードをサポートするので、ツールはdocumentation tipsと一緒に利用可能な関数の一覧や、特定のシグネチャーで関数が呼び出された場合に正しいドキュメントを表示することができます。

A typical client would not need to add any additional typing but could just use a community-supplied typing to discover (through statement completion with documentation tips) and verify (through static checking) correct use of the library, as in the following screen shot.

典型的なclientは余計なタイピングを望んでいませんが、以下のスクリーンショットのように、(ステートメント補完やdocumentation tipsを通じた)コミュニティから提供されたタイピングを探したり、(静的チェックを通じて)ライブラリを正しく使っているか検証をします。

Section 3.3 provides additional information about object types.

セクション3.3ではobject型に関する追加情報が提供されています。

## 1.4 構造的部分型(Structural Subtyping)

Object types are compared *structurally*. For example, in the code fragment below, class `CPoint` matches interface `Point` because `CPoint` has all of the required members of `Point`. A class may optionally declare that it implements an interface, so that the compiler will check the declaration for structural compatibility. The example also illustrates that an object type can match the type inferred from an object literal, as long as the object literal supplies all of the required members.

object型は`構造的`に比較されます。例えば以下のようなコード片において、`CPoint`クラスは`Point`インターフェースが要求するメンバを全て持っているため、`CPoint`クラスは`Point`インターフェースに適合します。クラスはインターフェースを実装することをオプションで宣言できるので、コンパイラは宣言の構造互換性をチェックします。またこの例は、objectリテラルが要求されたメンバを提供しているのであれば、object型リテラルから推論された型とobject型が適合することを例示しています。

```typescript
interface Point {
    x: number;
    y: number;
}

function getX(p: Point) {
    return p.x;
}

class CPoint {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
}

getX(new CPoint(0, 0)); // Ok, fields match

getX({ x: 0, y: 0, color: "red" }); // Extra fields Ok

getX({ x: 0 }); // Error: supplied parameter does not match
```

See section 3.8 for more information about type comparisons.

セクション3.8では型比較に関する追加情報が提供されています。

## 1.5 コンテキストに沿った型付け(Contextual Typing)

Ordinarily, TypeScript type inference proceeds "bottom-up": from the leaves of an expression tree to its root. In the following example, TypeScript infers `number` as the return type of the function `mul` by flowing type information bottom up in the return expression.

TypeScriptにおける型推論は、式木のリーフからルートに向かって"ボトムアップ"で処理されます。以下の例では、TypaScriptはreturnステートメントに記述された内容の型情報からボトムアップに探索することで、関数`mul`の戻り値を`number`だと推論します。

```typescript
function mul(a: number, b: number) {
    return a * b;
}
```

For variables and parameters without a type annotation or a default value, TypeScript infers type `any`, ensuring that compilers do not need non-local information about a function's call sites to infer the function's return type. Generally, this bottom-up approach provides programmers with a clear intuition about the flow of type information.

型注釈やデフォルト値が指定されていない変数やパラメータについて、TypeScriptは`any`型だと推論し、コンパイラが関数の戻り値型を推論するために関数の呼び出しサイトに関する非局所情報を要求しないことを保証します。通常であればこのボトムアップ・アプローチは、プログラマーへ型情報の流れに関する直感的な理解を提供します。

However, in some limited contexts, inference proceeds "top-down" from the context of an expression. Where this happens, it is called contextual typing. Contextual typing helps tools provide excellent information when a programmer is using a type but may not know all of the details of the type. For example, in the jQuery example, above, the programmer supplies a function expression as the second parameter to the `get` method. During typing of that expression, tools can assume that the type of the function expression is as given in the `get` signature and can provide a template that includes parameter names and types.

しかし一部の限られたコンテキストでは、推論は式のコンテキストから"トップダウン"で処理されます。このことが発生することをコンテキストに沿った型付けと呼びます。コンテキストに沿った型付けは、プログラマーがある型を使おうとした時に詳細がわからない場合、ツールから適した情報を提供する際の助けとなります。jQueryを例にすると、プログラマーは`get`メソッドの2つ目の引数として関数式を与えます。この式をタイプしている間、ツールは関数式の型が`get`メソッドのシグネチャーとして与えられると認識し、パラメーター名と型を含んだテンプレートを提供します。

```typescript
$.get("http://mysite.org/divContent",
    function (data) {
        $("div").text(data); // TypeScript infers data is a string
    }
);
```

Contextual typing is also useful for writing out object literals. As the programmer types the object literal, the contextual type provides information that enables tools to provide completion for object member names.

コンテキストに沿った型付けはobjectリテラルを記述する際にも有効です。objectリテラルを記述しているプログラマーへ、コンテキストに沿った型付けはオブジェクトメンバー名を補完するツールのための情報を提供することができます。

Section 4.19 provides additional information about contextually typed expressions.

セクション4.19ではコンテキストに沿った型付け式に関する追加情報が提供されています。

## 1.6 クラス(Classes)

JavaScript practice has at least two common design patterns: the module pattern and the class pattern. Roughly speaking, the module pattern uses closures to hide names and to encapsulate private data, while the class pattern uses prototype chains to implement many variations on object-oriented inheritance mechanisms. Libraries such as `prototype.js` are typical of this practice.

JavaScriptのプラクティスとして「モジュールパターン」と「クラスパターン」の少なくとも2つの一般的なデザインパターンがあります。大まかには、モジュールパターンは名前を隠したりプライベートデータをカプセル化するためにクロージャーを利用し、クラスパターンはオブジェクト指向の継承メカニズム上での多様な実装をするためにプロトタイプチェーンを用います。`prototype.js`のようなライブラリは、このプラクティスの典型です。

This section and the module section below will show how TypeScript emits consistent, idiomatic JavaScript code to implement classes and modules that are closely aligned with the current ES6 proposal. The goal of TypeScript's translation is to emit exactly what a programmer would type when implementing a class or module unaided by a tool. This section will also describe how TypeScript infers a type for each class declaration. We'll start with a simple BankAccount class.

このセクションと後出のするモジュールのセクションでは、現在のES6プロポーザルと密接に関連したクラスとモジュールを実装する慣用的で一貫性を保ったJavaScriptコードを、TypeScriptがどのように発行しているかを説明します。TypeScriptの変換のゴールは、プログラマーがツールの助けなしにクラスやモジュールを実装した際に記述したものを正確に出力することです。このセクションではTypeScriptがどのように各クラス宣言から型を推論するかについても説明します。まず始めにシンプルなBankAccountクラスがあります。

```typescript
class BankAccount {
    balance = 0;
    deposit(credit: number) {
        this.balance += credit;
        return this.balance;
    }
}
```

This class generates the following JavaScript code.

このクラスからは以下のようなJavaScriptコードが生成されます。

```typescript
var BankAccount = (function () {
    function BankAccount() {
        this.balance = 0;
    }
    BankAccount.prototype.deposit = function(credit) {
        this.balance += credit;
        return this.balance;
    };
    return BankAccount;
})();
```

This TypeScript class declaration creates a variable named `BankAccount` whose value is the constructor function for `BankAccount` instances. This declaration also creates an instance type of the same name. If we were to write this type as an interface it would look like the following.

このTypeScriptのクラス宣言は`BankAccount`インスタンスのコンストラクター関数の値を持つ`BankAccount`という名前の変数を作成します。この宣言は同じ名前のインスタンス型も作成します。この型をインターフェースとして記述すると以下のようになります。

```typescript
interface BankAccount {
    balance: number;
    deposit(credit: number): number;
}
```

If we were to write out the function type declaration for the `BankAccount` constructor variable, it would have the following form.

`BankAccount`のコンストラクタとして関数型の変数宣言を記述した場合、以下のような形式になります。

```typescript
var BankAccount: new() => BankAccount;
```

The function signature is prefixed with the keyword `new` indicating that the `BankAccount` function must be called as a constructor. It is possible for a function's type to have both call and constructor signatures. For example, the type of the built-in JavaScript Date object includes both kinds of signatures.

この関数のシグネチャーは、`BankAccount`関数がコンストラクターとして確実に呼び出されることを示すために、`new`キーワードがプレフィックスされています。関数とコンストラクタの両方のシグネチャーを持つ関数型を作ることが可能です。例えばJavaScriptにビルトインされているDateオブジェクトの型には、両方の種類のシグネチャが含まれています。

If we want to start our bank account with an initial balance, we can add to the `BankAccount` class a constructor declaration.

銀行口座を初期残額から作成したい場合、`BankAccount`クラスにコンストラクター宣言を追加することができます。

```typescript
class BankAccount {
    balance: number;
    constructor(initially: number) {
        this.balance = initially;
    }
    deposit(credit: number) {
        this.balance += credit;
        return this.balance;
    }
}
```

This version of the `BankAccount` class requires us to introduce a constructor parameter and then assign it to the `balance` field. To simplify this common case, TypeScript accepts the following shorthand syntax.

このバージョンの`BankAccount`クラスはコンストラクターのパラメーターを指定することを要求し、`balance`フィールドに値を代入します。このような一般的なケースをシンプルにするためにTypeScriptでは速記構文を利用できます。

```typescript
class BankAccount {
    constructor(public balance: number) {
    }
    deposit(credit: number) {
        this.balance += credit;
        return this.balance;
    }
}
```

The `public` keyword denotes that the constructor parameter is to be retained as a field. Public is the default visibility for class members, but a programmer can also specify private visibility for a class member. Private visibility is a design-time construct; it is enforced during static type checking but does not imply any runtime enforcement.

コンストラクターのパラメーターに`public`キーワードが付けられたものは、フィールドとして値が保持されます。publicはクラスメンバーのデフォルトの可視性ですが、プログラマーはクラスメンバーに対してprivateの可視性を指定することも可能です。privateの可視性はデザイン時の概念です。静的型チェックの際には有効ですが、実行時には効力がありません。

TypeScript classes also support inheritance, as in the following example.

```typescript
class CheckingAccount extends BankAccount {
    constructor(balance: number) {
        super(balance);
    }
    writeCheck(debit: number) {
        this.balance -= debit;
    }
}
```

In this example, the class `CheckingAccount` derives from class `BankAccount`. The constructor for `CheckingAccount` calls the constructor for class `BankAccount` using the `super` keyword. In the emitted JavaScript code, the prototype of `CheckingAccount` will chain to the prototype of `BankingAccount`.

TypeScript classes may also specify static members. Static class members become properties of the class constructor.

Section 8 provides additional information about classes.

## 1.7 Enum Types

TypeScript enables programmers to summarize a set of numeric constants as an *enum type*. The example
below creates an enum type to represent operators in a calculator application.

```typescript
enum Operator {
    ADD,
    DIV,
    MUL,
    SUB
}

function compute(op: Operator, a: number, b: number) {
    console.log("the operator is" + Operator[op]);
    // ...
}
```

In this example, the compute function logs the operator `op` using a feature of enum types: reverse mapping from the enum value (`op`) to the string corresponding to that value. For example, the declaration of `Operator` automatically assigns integers, starting from zero, to the listed enum members. Section 9 describes how programmers can also explicitly assign integers to enum members, and can use any string to name an enum member.

If all enum members have explicitly assigned literal integers, or if an enum has all members automatically assigned, the TypeScript compiler will emit for an enum member a JavaScript constant corresponding to that member's assigned value (annotated with a comment). This improves performance on many JavaScript engines.

For example, the `compute` function could contain a switch statement like the following.


```typescript
switch (op) {
    case Operator.ADD:
        // execute add
        break;
    case Operator.DIV:
        // execute div
        break;
    // ...
}
```

For this switch statement, the compiler will generate the following code.
  
```typescript
switch (op) {
    case 0 /* Operator.ADD */ :
        // execute add
        break;
    case 1 /* Operator.DIV */ :
        // execute div
        break;
    // ...
}
```

JavaScript implementations can use these explicit constants to generate efficient code for this switch statement, for example by building a jump table indexed by case value.

## 1.8 Overloading on String Parameters

An important goal of TypeScript is to provide accurate and straightforward types for existing JavaScript programming patterns. To that end, TypeScript includes generic types, discussed in the next section, and *overloading on string parameters*, the topic of this section.

JavaScript programming interfaces often include functions whose behavior is discriminated by a string constant passed to the function. The Document Object Model makes heavy use of this pattern. For example, the following screen shot shows that the `createElement` method of the `document` object has multiple signatures, some of which identify the types returned when specific strings are passed into the method.

The following code fragment uses this feature. Because the `span` variable is inferred to have the type `HTMLSpanElement`, the code can reference without static error the `isMultiline` property of `span`.

```typescript
var span = document.createElement("span");
span.isMultiLine = false; // OK: HTMLSpanElement has an 'isMultiline' property
```

In the following screen shot, a programming tool combines information from overloading on string parameters with contextual typing to infer that the type of the variable `e` is `MouseEvent` and that therefore `e` has a `clientX` property.

Section 3.7.2.4 provides details on how to use string literals in function signatures.

## 1.9 Generic Types and Functions

Like overloading on string parameters, *generic types* make it easier for TypeScript to accurately capture the behavior of JavaScript libraries. Because they enable type information to flow from client code, through library code, and back into client code, generic types may do more than any other TypeScript feature to support detailed API descriptions.

To illustrate this, let's take a look at part of the TypeScript interface for the built-in JavaScript array type. You can find this interface in the `lib.d.ts` file that accompanies a TypeScript distribution.

```typescript
interface Array<T> {
    reverse(): T[];
    sort(compareFn?: (a: T, b: T) => number): T[];
    // ...
}
```

Interface definitions, like the one above, can have one or more *type parameters*. In this case the `Array` interface has a single parameter, `T`, that defines the element type for the array. The `reverse` method returns an array with the same element type. The sort method takes an optional parameter, `compareFn`, whose type is a function that takes two parameters of type `T` and returns a number. Finally, sort returns an array with element type `T`.

Functions can also have generic parameters. For example, the array interface contains a `map` method, defined as follows:

```typescript
map<U>(func: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];
```

The map method, invoked on an array `a` with element type `T`, will apply function `func` to each elementof `a`, returning a value of type `U`.

The TypeScript compiler can often infer generic method parameters, making it unnecessary for the programmer to explicitly provide them. In the following example, the compiler infers that parameter `U` of the map method has type `string`, because the function passed to map returns a string.

```typescript
function numberToString(a: number[]) {
    var stringArray = a.map(v => v.toString());
    return stringArray;
}
```

The compiler infers in this example that the `numberToString` function returns an array of strings.

In TypeScript, classes can also have type parameters. The following code declares a class that implements a linked list of items of type `T`. This code illustrates how programmers can constrain type parameters to extend a specific type. In this case, the items on the list must extend the type `NamedItem`. This enables the programmer to implement the `log` function, which logs the name of the item.

```typescript
interface NamedItem {
    name: string;
}

class List<T extends NamedItem> {
    next: List<T> = null;

    constructor(public item: T) {
    }

    insertAfter(item: T) {
        var temp = this.next;
        this.next = new List(item);
        this.next.next = temp;
    }

    log() {
        console.log(this.item.name);
    }

    // ...
}
```

Section 3.5 provides further information about generic types.

## 1.10 Modules

Classes and interfaces support large-scale JavaScript development by providing a mechanism for describing how to use a software component that can be separated from that component's implementation. TypeScript enforces encapsulation of implementation in classes at design time (by restricting use of private members), but cannot enforce encapsulation at runtime because all object properties are accessible at runtime. Future versions of JavaScript may provide *private names* which would enable runtime enforcement of private members.

In the current version of JavaScript, the only way to enforce encapsulation at runtime is to use the module pattern: encapsulate private fields and methods using closure variables. The module pattern is a natural way to provide organizational structure and dynamic loading options by drawing a boundary around a software component. A module can also provide the ability to introduce namespaces, avoiding use of the global namespace for most software components.

The following example illustrates the JavaScript module pattern.

```typescript
(function(exports) {
    var key = generateSecretKey();
    function sendMessage(message) {
        sendSecureMessage(message, key);
    }
    exports.sendMessage = sendMessage;
})(MessageModule);
```

This example illustrates the two essential elements of the module pattern: a *module closure* and a *module object*. The module closure is a function that encapsulates the module's implementation, in this case the variable `key` and the function `sendMessage`. The module object contains the exported variables and functions of the module. Simple modules may create and return the module object. The module above takes the module object as a parameter, `exports`, and adds the `sendMessage` property to the module object. This *augmentation* approach simplifies dynamic loading of modules and also supports separation of module code into multiple files.

The example assumes that an outer lexical scope defines the functions `generateSecretKey` and `sendSecureMessage`; it also assumes that the outer scope has assigned the module object to the variable `MessageModule`.

TypeScript modules provide a mechanism for succinctly expressing the module pattern. In TypeScript, programmers can combine the module pattern with the class pattern by nesting modules and classes within an outer module.

The following example shows the definition and use of a simple module.

```typescript
module M {
    var s = "hello";
    export function f() {
        return s;
    }
}

M.f();
M.s; // Error, s is not exported
```

In this example, variable `s` is a private feature of the module, but function `f` is exported from the module and accessible to code outside of the module. If we were to describe the effect of module `M` in terms of interfaces and variables, we would write

```typescript
interface M {
    f(): string;
}

var M: M;
```

The interface `M` summarizes the externally visible behavior of module `M`. In this example, we can use the same name for the interface as for the initialized variable because in TypeScript type names and variable names do not conflict: each lexical scope contains a variable declaration space and type declaration space (see section 2.3 for more details).

Module `M` is an example of an *internal* module, because it is nested within the *global* module (see section 10 for more details). The TypeScript compiler emits the following JavaScript code for this module.

```typescript
var M;
(function(M) {
    var s = "hello";
    function f() {
        return s;
    }
    M.f = f;
})(M||(M={}));
```

In this case, the compiler assumes that the module object resides in global variable `M`, which may or may not have been initialized to the desired module object.

TypeScript also supports *external* modules, which are files that contain top-level *export* and *import* directives. For this type of module the TypeScript compiler will emit code whose module closure and module object implementation vary according to the specified dynamic loading system, for example, the Asynchronous Module Definition system.
